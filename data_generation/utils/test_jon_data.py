#!/usr/bin/env python
"""
Test Jon synthetic data generated by jon_data_generator.py.
Supports both retrieval API and fine-tuning formats.
"""

import os
import sys
import json
import argparse
from typing import Dict, List, Any, Optional
from datetime import datetime

def test_qa_data(qa_data: List[Dict[str, Any]]) -> bool:
    """Test Q&A data format and content
    
    Args:
        qa_data: List of Q&A pairs to test
        
    Returns:
        True if all tests pass
    """
    print("\nTesting Q&A data...")
    all_passed = True
    
    for i, qa in enumerate(qa_data):
        # Check required fields
        if not all(field in qa for field in ["question", "answer", "metadata"]):
            print(f"❌ Q&A pair {i} missing required fields")
            all_passed = False
            continue
            
        # Check metadata
        metadata = qa.get("metadata", {})
        if not all(field in metadata for field in ["topics", "entities", "version"]):
            print(f"❌ Q&A pair {i} missing required metadata fields")
            all_passed = False
            continue
            
        # Check content
        if not qa["question"].strip() or not qa["answer"].strip():
            print(f"❌ Q&A pair {i} has empty question or answer")
            all_passed = False
            continue
            
        # Check version
        if metadata.get("version") != "2.0":
            print(f"❌ Q&A pair {i} has incorrect version")
            all_passed = False
            continue
    
    if all_passed:
        print(f"✅ All {len(qa_data)} Q&A pairs passed validation")
    return all_passed

def test_conversation_data(conversation_data: List[Dict[str, Any]]) -> bool:
    """Test conversation data format and content
    
    Args:
        conversation_data: List of conversations to test
        
    Returns:
        True if all tests pass
    """
    print("\nTesting conversation data...")
    all_passed = True
    
    for i, conv in enumerate(conversation_data):
        # Check required fields
        if not all(field in conv for field in ["messages", "metadata"]):
            print(f"❌ Conversation {i} missing required fields")
            all_passed = False
            continue
            
        # Check messages
        messages = conv.get("messages", [])
        if not messages:
            print(f"❌ Conversation {i} has no messages")
            all_passed = False
            continue
            
        # Check message format
        for j, msg in enumerate(messages):
            if not all(field in msg for field in ["role", "content"]):
                print(f"❌ Message {j} in conversation {i} missing required fields")
                all_passed = False
                continue
                
            if msg["role"] not in ["user", "assistant"]:
                print(f"❌ Message {j} in conversation {i} has invalid role")
                all_passed = False
                continue
                
            if not msg["content"].strip():
                print(f"❌ Message {j} in conversation {i} has empty content")
                all_passed = False
                continue
    
    if all_passed:
        print(f"✅ All {len(conversation_data)} conversations passed validation")
    return all_passed

def test_statement_data(statement_data: List[Dict[str, Any]]) -> bool:
    """Test statement data format and content
    
    Args:
        statement_data: List of statements to test
        
    Returns:
        True if all tests pass
    """
    print("\nTesting statement data...")
    all_passed = True
    
    for i, stmt in enumerate(statement_data):
        # Check required fields
        if not all(field in stmt for field in ["statement", "metadata"]):
            print(f"❌ Statement {i} missing required fields")
            all_passed = False
            continue
            
        # Check metadata
        metadata = stmt.get("metadata", {})
        if not all(field in metadata for field in ["topics", "sentiment", "version"]):
            print(f"❌ Statement {i} missing required metadata fields")
            all_passed = False
            continue
            
        # Check content
        if not stmt["statement"].strip():
            print(f"❌ Statement {i} is empty")
            all_passed = False
            continue
            
        # Check version
        if metadata.get("version") != "2.0":
            print(f"❌ Statement {i} has incorrect version")
            all_passed = False
            continue
    
    if all_passed:
        print(f"✅ All {len(statement_data)} statements passed validation")
    return all_passed

def test_retrieval_data(file_path: str) -> bool:
    """Test retrieval data format and content
    
    Args:
        file_path: Path to the retrieval data file
        
    Returns:
        True if all tests pass
    """
    print("\nTesting retrieval data...")
    all_passed = True
    
    try:
        with open(file_path, 'r') as f:
            lines = f.readlines()
            
        for i, line in enumerate(lines):
            try:
                data = json.loads(line)
                
                # Check required fields
                if not all(field in data for field in ["text", "metadata"]):
                    print(f"❌ Line {i+1} missing required fields")
                    all_passed = False
                    continue
                    
                # Check metadata
                metadata = data.get("metadata", {})
                if not all(field in metadata for field in ["type", "version"]):
                    print(f"❌ Line {i+1} missing required metadata fields")
                    all_passed = False
                    continue
                    
                # Check content
                if not data["text"].strip():
                    print(f"❌ Line {i+1} has empty text")
                    all_passed = False
                    continue
                    
                # Check version
                if metadata.get("version") != "2.0":
                    print(f"❌ Line {i+1} has incorrect version")
                    all_passed = False
                    continue
                    
            except json.JSONDecodeError:
                print(f"❌ Line {i+1} is not valid JSON")
                all_passed = False
                continue
        
        if all_passed:
            print(f"✅ All {len(lines)} retrieval items passed validation")
        return all_passed
        
    except Exception as e:
        print(f"❌ Error testing retrieval data: {e}")
        return False

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="Test Jon synthetic data")
    parser.add_argument("--input", type=str, required=True, help="Input file to test")
    parser.add_argument("--test-retrieval", action="store_true", help="Test retrieval data format")
    args = parser.parse_args()
    
    if not os.path.exists(args.input):
        print(f"Error: Input file not found: {args.input}")
        sys.exit(1)
    
    try:
        # Test retrieval data format
        if args.test_retrieval:
            success = test_retrieval_data(args.input)
            sys.exit(0 if success else 1)
        
        # Test raw data format
        with open(args.input, 'r') as f:
            data = json.load(f)
        
        # Run tests
        qa_success = test_qa_data(data.get("qa_data", []))
        conv_success = test_conversation_data(data.get("conversation_data", []))
        stmt_success = test_statement_data(data.get("statement_data", []))
        
        # Print summary
        print("\nTest Summary:")
        print(f"Q&A Data: {'✅ Passed' if qa_success else '❌ Failed'}")
        print(f"Conversation Data: {'✅ Passed' if conv_success else '❌ Failed'}")
        print(f"Statement Data: {'✅ Passed' if stmt_success else '❌ Failed'}")
        
        sys.exit(0 if all([qa_success, conv_success, stmt_success]) else 1)
        
    except Exception as e:
        print(f"Error testing data: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 